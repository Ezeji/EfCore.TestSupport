<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TestSupport</name>
    </assembly>
    <members>
        <member name="T:Xunit.Extensions.AssertExtensions.BooleanAssertionExtensions">
            <summary>
            Extensions which provide assertions to classes derived from <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.BooleanAssertionExtensions.ShouldBeFalse(System.Boolean)">
            <summary>
            Verifies that the condition is false.
            </summary>
            <param name="condition">The condition to be tested</param>
            <exception cref="!:FalseException">Thrown if the condition is not false</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.BooleanAssertionExtensions.ShouldBeFalse(System.Boolean,System.String)">
            <summary>
            Verifies that the condition is false.
            </summary>
            <param name="condition">The condition to be tested</param>
            <param name="userMessage">The message to show when the condition is not false</param>
            <exception cref="!:FalseException">Thrown if the condition is not false</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.BooleanAssertionExtensions.ShouldBeTrue(System.Boolean)">
            <summary>
            Verifies that an expression is true.
            </summary>
            <param name="condition">The condition to be inspected</param>
            <exception cref="!:TrueException">Thrown when the condition is false</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.BooleanAssertionExtensions.ShouldBeTrue(System.Boolean,System.String)">
            <summary>
            Verifies that an expression is true.
            </summary>
            <param name="condition">The condition to be inspected</param>
            <param name="userMessage">The message to be shown when the condition is false</param>
            <exception cref="!:TrueException">Thrown when the condition is false</exception>
        </member>
        <member name="T:Xunit.Extensions.AssertExtensions.CollectionAssertExtensions">
            <summary>
            Extensions which provide assertions to classes derived from <see cref="T:System.Collections.IEnumerable"/> and <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.CollectionAssertExtensions.ShouldBeEmpty(System.Collections.IEnumerable)">
            <summary>
            Verifies that a collection is empty.
            </summary>
            <param name="collection">The collection to be inspected</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the collection is null</exception>
            <exception cref="!:EmptyException">Thrown when the collection is not empty</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.CollectionAssertExtensions.ShouldContain``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Verifies that a collection contains a given object.
            </summary>
            <typeparam name="T">The type of the object to be verified</typeparam>
            <param name="collection">The collection to be inspected</param>
            <param name="expected">The object expected to be in the collection</param>
            <exception cref="!:ContainsException">Thrown when the object is not present in the collection</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.CollectionAssertExtensions.ShouldContain``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Verifies that a collection contains a given object, using a comparer.
            </summary>
            <typeparam name="T">The type of the object to be verified</typeparam>
            <param name="collection">The collection to be inspected</param>
            <param name="expected">The object expected to be in the collection</param>
            <param name="comparer">The comparer used to equate objects in the collection with the expected object</param>
            <exception cref="!:ContainsException">Thrown when the object is not present in the collection</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.CollectionAssertExtensions.ShouldNotBeEmpty(System.Collections.IEnumerable)">
            <summary>
            Verifies that a collection is not empty.
            </summary>
            <param name="collection">The collection to be inspected</param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null collection is passed</exception>
            <exception cref="!:NotEmptyException">Thrown when the collection is empty</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.CollectionAssertExtensions.ShouldNotContain``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Verifies that a collection does not contain a given object.
            </summary>
            <typeparam name="T">The type of the object to be compared</typeparam>
            <param name="expected">The object that is expected not to be in the collection</param>
            <param name="collection">The collection to be inspected</param>
            <exception cref="!:DoesNotContainException">Thrown when the object is present inside the container</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.CollectionAssertExtensions.ShouldNotContain``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Verifies that a collection does not contain a given object, using a comparer.
            </summary>
            <typeparam name="T">The type of the object to be compared</typeparam>
            <param name="expected">The object that is expected not to be in the collection</param>
            <param name="collection">The collection to be inspected</param>
            <param name="comparer">The comparer used to equate objects in the collection with the expected object</param>
            <exception cref="!:DoesNotContainException">Thrown when the object is present inside the container</exception>
        </member>
        <member name="T:Xunit.Extensions.AssertExtensions.ExtraStringAssertionExtensions">
            <summary>
            Extra AssertExtensions that I find useful
            </summary>
        </member>
        <member name="T:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions">
            <summary>
            Extensions which provide assertions to classes derived from <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldBeInRange``1(``0,``0,``0)">
            <summary>
            Verifies that a value is within a given range.
            </summary>
            <typeparam name="T">The type of the value to be compared</typeparam>
            <param name="actual">The actual value to be evaluated</param>
            <param name="low">The (inclusive) low value of the range</param>
            <param name="high">The (inclusive) high value of the range</param>
            <exception cref="!:InRangeException">Thrown when the value is not in the given range</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldBeInRange``1(``0,``0,``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Verifies that a value is within a given range, using a comparer.
            </summary>
            <typeparam name="T">The type of the value to be compared</typeparam>
            <param name="actual">The actual value to be evaluated</param>
            <param name="low">The (inclusive) low value of the range</param>
            <param name="high">The (inclusive) high value of the range</param>
            <param name="comparer">The comparer used to evaluate the value's range</param>
            <exception cref="!:InRangeException">Thrown when the value is not in the given range</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldBeNull(System.Object)">
            <summary>
            Verifies that an object reference is null.
            </summary>
            <param name="object">The object to be inspected</param>
            <exception cref="!:NullException">Thrown when the object reference is not null</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldBeSameAs(System.Object,System.Object)">
            <summary>
            Verifies that two objects are the same instance.
            </summary>
            <param name="actual">The actual object instance</param>
            <param name="expected">The expected object instance</param>
            <exception cref="!:SameException">Thrown when the objects are not the same instance</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldBeType``1(System.Object)">
            <summary>
            Verifies that an object is exactly the given type (and not a derived type).
            </summary>
            <typeparam name="T">The type the object should be</typeparam>
            <param name="object">The object to be evaluated</param>
            <returns>The object, casted to type T when successful</returns>
            <exception cref="!:IsTypeException">Thrown when the object is not the given type</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldBeType(System.Object,System.Type)">
            <summary>
            Verifies that an object is exactly the given type (and not a derived type).
            </summary>
            <param name="object">The object to be evaluated</param>
            <param name="expectedType">The type the object should be</param>
            <exception cref="!:IsTypeException">Thrown when the object is not the given type</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldEqual``1(``0,``0)">
            <summary>
            Verifies that two objects are equal, using a default comparer.
            </summary>
            <typeparam name="T">The type of the objects to be compared</typeparam>
            <param name="actual">The value to be compared against</param>
            <param name="expected">The expected value</param>
            <exception cref="!:EqualException">Thrown when the objects are not equal</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldEqual``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Verifies that two objects are equal, using a custom comparer.
            </summary>
            <typeparam name="T">The type of the objects to be compared</typeparam>
            <param name="actual">The value to be compared against</param>
            <param name="expected">The expected value</param>
            <param name="comparer">The comparer used to compare the two objects</param>
            <exception cref="!:EqualException">Thrown when the objects are not equal</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldNotBeInRange``1(``0,``0,``0)">
            <summary>
            Verifies that a value is not within a given range, using the default comparer.
            </summary>
            <typeparam name="T">The type of the value to be compared</typeparam>
            <param name="actual">The actual value to be evaluated</param>
            <param name="low">The (inclusive) low value of the range</param>
            <param name="high">The (inclusive) high value of the range</param>
            <exception cref="!:NotInRangeException">Thrown when the value is in the given range</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldNotBeInRange``1(``0,``0,``0,System.Collections.Generic.IComparer{``0})">
            <summary>
            Verifies that a value is not within a given range, using a comparer.
            </summary>
            <typeparam name="T">The type of the value to be compared</typeparam>
            <param name="actual">The actual value to be evaluated</param>
            <param name="low">The (inclusive) low value of the range</param>
            <param name="high">The (inclusive) high value of the range</param>
            <param name="comparer">The comparer used to evaluate the value's range</param>
            <exception cref="!:NotInRangeException">Thrown when the value is in the given range</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldNotBeNull(System.Object)">
            <summary>
            Verifies that an object reference is not null.
            </summary>
            <param name="object">The object to be validated</param>
            <exception cref="!:NotNullException">Thrown when the object is not null</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldNotBeSameAs(System.Object,System.Object)">
            <summary>
            Verifies that two objects are not the same instance.
            </summary>
            <param name="actual">The actual object instance</param>
            <param name="expected">The expected object instance</param>
            <exception cref="!:NotSameException">Thrown when the objects are the same instance</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldNotBeType``1(System.Object)">
            <summary>
            Verifies that an object is not exactly the given type.
            </summary>
            <typeparam name="T">The type the object should not be</typeparam>
            <param name="object">The object to be evaluated</param>
            <exception cref="!:IsTypeException">Thrown when the object is the given type</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldNotBeType(System.Object,System.Type)">
            <summary>
            Verifies that an object is not exactly the given type.
            </summary>
            <param name="object">The object to be evaluated</param>
            <param name="expectedType">The type the object should not be</param>
            <exception cref="!:IsTypeException">Thrown when the object is the given type</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldNotEqual``1(``0,``0)">
            <summary>
            Verifies that two objects are not equal, using a default comparer.
            </summary>
            <typeparam name="T">The type of the objects to be compared</typeparam>
            <param name="actual">The actual object</param>
            <param name="expected">The expected object</param>
            <exception cref="!:NotEqualException">Thrown when the objects are equal</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.ObjectAssertExtensions.ShouldNotEqual``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Verifies that two objects are not equal, using a custom comparer.
            </summary>
            <typeparam name="T">The type of the objects to be compared</typeparam>
            <param name="actual">The actual object</param>
            <param name="expected">The expected object</param>
            <param name="comparer">The comparer used to examine the objects</param>
            <exception cref="!:NotEqualException">Thrown when the objects are equal</exception>
        </member>
        <member name="T:Xunit.Extensions.AssertExtensions.StringAssertionExtensions">
            <summary>
            Extensions which provide assertions to classes derived from <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.StringAssertionExtensions.ShouldContain(System.String,System.String)">
            <summary>
            Verifies that a string contains a given sub-string, using the current culture.
            </summary>
            <param name="actualString">The string to be inspected</param>
            <param name="expectedSubString">The sub-string expected to be in the string</param>
            <exception cref="!:ContainsException">Thrown when the sub-string is not present inside the string</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.StringAssertionExtensions.ShouldContain(System.String,System.String,System.StringComparison)">
            <summary>
            Verifies that a string contains a given sub-string, using the given comparison type.
            </summary>
            <param name="actualString">The string to be inspected</param>
            <param name="expectedSubString">The sub-string expected to be in the string</param>
            <param name="comparisonType">The type of string comparison to perform</param>
            <exception cref="!:ContainsException">Thrown when the sub-string is not present inside the string</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.StringAssertionExtensions.ShouldNotContain(System.String,System.String)">
            <summary>
            Verifies that a string does not contain a given sub-string, using the current culture.
            </summary>
            <param name="actualString">The string to be inspected</param>
            <param name="expectedSubString">The sub-string which is expected not to be in the string</param>
            <exception cref="!:DoesNotContainException">Thrown when the sub-string is present inside the string</exception>
        </member>
        <member name="M:Xunit.Extensions.AssertExtensions.StringAssertionExtensions.ShouldNotContain(System.String,System.String,System.StringComparison)">
            <summary>
            Verifies that a string does not contain a given sub-string, using the current culture.
            </summary>
            <param name="actualString">The string to be inspected</param>
            <param name="expectedSubString">The sub-string which is expected not to be in the string</param>
            <param name="comparisonType">The type of string comparison to perform</param>
            <exception cref="!:DoesNotContainException">Thrown when the sub-string is present inside the given string</exception>
        </member>
        <member name="T:TestSupport.Attributes.RunnableInDebugOnlyAttribute">
            <summary>
            Useful attribute for stopping a test from being run
            see https://lostechies.com/jimmybogard/2013/06/20/run-tests-explicitly-in-xunit-net/ 
            </summary>
        </member>
        <member name="M:TestSupport.Attributes.RunnableInDebugOnlyAttribute.#ctor">
            <summary>
            By putting this attribute on a test instead of the normal [Fact] attribute will mean the 
            test will only run if in debug mode.
            This is useful for stopping unit tests that should not be run in the normal run of unit tests
            </summary>
        </member>
        <member name="T:TestSupport.EfHelpers.ApplyScriptExtension">
            <summary>
            Static class holding extension methods for applying SQL scripts to a database
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.ApplyScriptExtension.ExecuteScriptFileInTransaction(Microsoft.EntityFrameworkCore.DbContext,System.String)">
            <summary>
            This reads in a SQL script file and executes each command to the database pointed at by the DbContext
            Each command should have an GO at the start of the line after the command.
            </summary>
            <param name="context"></param>
            <param name="filePath"></param>
        </member>
        <member name="T:TestSupport.EfHelpers.CleanDatabaseExtensions">
            <summary>
            Static class holding the EnsureClean extension method
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.CleanDatabaseExtensions.EnsureClean(Microsoft.EntityFrameworkCore.Infrastructure.DatabaseFacade,System.Boolean)">
            <summary>
            Calling this will wipe the database schema down to nothing in the database and then calls
            Database.EnsureCreated to create the correct database schema based on your EF Core Context
            NOTE: This only works for SQL Server
            </summary>>
            <param name="databaseFacade">The Database property of the current DbContext that you want to clean</param>
            <param name="setUpSchema">Optional: by default it will set the schema to match the current DbContext configuration. If false leaves the database empty</param>
        </member>
        <member name="T:TestSupport.EfHelpers.CosmosDbExtensions">
            <summary>
            Extensions to provide Cosmos DB options where the Database/Container is held in the Azure Cosmos DB Emulator.
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.CosmosDbExtensions.GetCosmosDbToEmulatorOptions``1(System.Object,System.Boolean,System.String)">
            <summary>
            This creates Cosmos DB options where the Database/Container is held in the Azure Cosmos DB Emulator.
            It uses the name of the object as the database name (normally "this", which is your unit test class.
            For method-level uniqueness set makeMethodUnique to true to add the calling method to end of the database name
            </summary>
            <typeparam name="T"></typeparam>
            <param name="callingClass">this object is used to get the name of the database</param>
            <param name="makeMethodUnique">optional: If set then add the calling method's name to the end of the object name.</param>
            <param name="callingMember"></param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.CosmosDbExtensions.GetCosmosDbToEmulatorOptions``1(System.String)">
            <summary>
            This creates Cosmos DB options where the Database/Container is held in the Azure Cosmos DB Emulator.
            The given string will be the database name
            </summary>
            <typeparam name="T"></typeparam>
            <param name="databaseName">name to use for database name.</param>
            <returns></returns>
        </member>
        <member name="T:TestSupport.EfHelpers.DatabaseTidyHelper">
            <summary>
            Extension methods for deleting all the databases used in the unit test
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.DatabaseTidyHelper.DeleteAllUnitTestDatabases">
            <summary>
            This will delete all the databases that start with the database name in the default connection string
            WARNING: This will delete multiple databases - make sure your DefaultConnection database name is unique!!!
            </summary>
            <returns>Number of databases deleted</returns>
        </member>
        <member name="M:TestSupport.EfHelpers.DatabaseTidyHelper.GetAllMatchingDatabases(System.String,System.String)">
            <summary>
            This returns all the matching databases that start with the orgDbStartsWith parameter 
            </summary>
            <param name="orgDbStartsWith">Start of database name</param>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.DatabaseTidyHelper.WipeCreateDatabase(System.String,System.Int32)">
            <summary>
            Wipes out the existing database and creates a new, empty one
            </summary>
            <param name="databaseConnectionString">a actual connection string</param>
            <param name="timeout">Defines a timeout for connection and the SQL DELETE/CREATE database commands</param>
        </member>
        <member name="T:TestSupport.EfHelpers.DbContextOptionsDisposable`1">
            <summary>
            This is used to return a class that implements <see cref="T:Microsoft.EntityFrameworkCore.DbContextOptions`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TestSupport.EfHelpers.DbContextOptionsDisposable`1.#ctor(Microsoft.EntityFrameworkCore.DbContextOptions{`0})">
            <summary>
            This creates the class and sets up the <see cref="T:Microsoft.EntityFrameworkCore.DbContextOptions`1"/> part and getting a reference to the connection
            </summary>
            <param name="baseOptions"></param>
        </member>
        <member name="M:TestSupport.EfHelpers.DbContextOptionsDisposable`1.StopNextDispose">
            <summary>
            Use this to stop the Dispose if you want to create a second context to the same connection.
            You should call this BEFORE you create the DbContext
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.DbContextOptionsDisposable`1.TurnOffDispose">
            <summary>
            If you have lots of separate application DbContext's then use this to stop the connection from being removed.
            But remember to call <see cref="M:TestSupport.EfHelpers.DbContextOptionsDisposable`1.ManualDispose"/> at the end of your unit test
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.DbContextOptionsDisposable`1.ManualDispose">
            <summary>
            If you used <see cref="M:TestSupport.EfHelpers.DbContextOptionsDisposable`1.TurnOffDispose"/>, then you should call this at the end of your unit test
            That will dispose the connection.
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.DbContextOptionsDisposable`1.Dispose">
            <summary>
            This disposes the Sqlite connection with holds the in-memory data 
            </summary>
        </member>
        <member name="T:TestSupport.EfHelpers.Internal.DesignProvider">
            <summary>
            This static class contains the methods to return a design-time service provider
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.Internal.DesignProvider.GetDesignTimeService(Microsoft.EntityFrameworkCore.Infrastructure.DatabaseFacade)">
            <summary>
            This returns the correct instance of the design time service for the current DbContext's Database property
            </summary>
            <param name="databaseFacade"></param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.Internal.DesignProvider.GetDesignTimeProvider(Microsoft.EntityFrameworkCore.Design.IDesignTimeServices)">
            <summary>
            This returns a DesignTimeProvider for the design time service instance that you provided
            </summary>
            <param name="designTimeService">This should be an instance of rhe design time service for the database provider</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.Internal.EfCoreLogDecoder.DecodeMessage(TestSupport.EfHelpers.LogOutput)">
            <summary>
            This will try and decode an EF Core "CommandExecuted" 
            </summary>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="T:TestSupport.EfHelpers.LogOutput">
            <summary>
            This holds logs produced by the MyLoggerProvider 
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogOutput.LogLevel">
            <summary>
            The logLevel of this log
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogOutput.EventId">
            <summary>
            The logging EventId - should be string for EF Core logs
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogOutput.Message">
            <summary>
            The message in the log
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogOutput.EfEventIdLastName">
            <summary>
            This returns the last part of an EF Core EventId name, or null if the eventId is not an EF Core one
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.LogOutput.ToString">
            <summary>
            Summary of the log
            </summary>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.LogOutput.DecodeMessage(System.Boolean)">
            <summary>
            This tries to build valid SQL commands on CommandExecuted logs, i.e. logs containing the SQL output
            by taking the values available from EnableSensitiveDataLogging and inserting them in place of the parameter.
            This makes it easier to copy the SQL produced by EF Core and run in SSMS etc.
            LIMITATIONS are:
            - It can't distinguish the different between an empty string and a null string - it default to null
            - It can't work out if its a byte[] or not, so byte[] is treated as a SQL string, WHICH WILL fail
            - Numbers are presented as SQL strings, e.g. 123 becomes '123'. SQL Server can handle that
            </summary>
            <param name="sensitiveLoggingEnabled"></param>
            <returns></returns>
        </member>
        <member name="T:TestSupport.EfHelpers.LogToOptions">
            <summary>
            This class allows you to define the various LogTo options
            NOTE: You can only set a value for one of the three filters: OnlyShow... and FilterFunction
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogToOptions.ShowLog">
            <summary>
            This controls the action being called. If set to false it will not call the action
            Defaults to true, i.e. returns all logs
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogToOptions.LogLevel">
            <summary>
            This sets the lowest LogLevel that will be returned
            Defaults to LogLevel.Information
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogToOptions.OnlyShowTheseCategories">
            <summary>
            This allows you to only show certain DbLoggerCategory, for instance
            new[] { DbLoggerCategory.Database.Command.Name }) would only show the Database.Command logs
            Defaults to null, i.e. not used 
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogToOptions.OnlyShowTheseEvents">
            <summary>
            This allows you to only show certain events, for instance
            new[] { CoreEventId.ContextInitialized }
            Defaults to null, i.e. not used 
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogToOptions.FilterFunction">
            <summary>
            This allows you to provide a method to filter the logs, for instance
            bool MyFilterFunction(EventId eventId, LogLevel logLevel) {...}
            Defaults to null, i.e. not used
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.LogToOptions.LoggerOptions">
            <summary>
            This allows you to set format of the log message, for instance
            DefaultWithUtcTime will use a UTC time instead the local time
            Defaults to None, which means no extra info is prepended to the message
            </summary>
        </member>
        <member name="T:TestSupport.EfHelpers.MyLoggerProviderActionOut">
            <summary>
            This provides a ILoggerProvider that returns logging output 
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.MyLoggerProviderActionOut.#ctor(System.Action{TestSupport.EfHelpers.LogOutput},Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            This is a logger provider that can be linked into a loggerFactory.
            It will capture the logs and place them as strings into the provided logs parameter
            </summary>
            <param name="efLog">required: a method that will be called when EF Core logs something</param>
            <param name="logLevel">optional: the level from with you want to capture logs. Defaults to LogLevel.Information</param>
        </member>
        <member name="M:TestSupport.EfHelpers.MyLoggerProviderActionOut.CreateLogger(System.String)">
            <summary>
            Create a logger that will return a log when it is called.
            </summary>
            <param name="categoryName"></param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.MyLoggerProviderActionOut.Dispose">
            <summary>
            Dispose - not used
            </summary>
        </member>
        <member name="T:TestSupport.EfHelpers.SqlAdoNetHelpers">
            <summary>
            Contains extension methods to help with base SQL commands 
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlAdoNetHelpers.ExecuteRowCount(System.String,System.String,System.String)">
            <summary>
            Execute a count of the rows in a table, with optional where clause, using ADO.NET
            </summary>
            <param name="connectionString"></param>
            <param name="tableName"></param>
            <param name="whereClause"></param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlAdoNetHelpers.ExecuteNonQuery(System.String,System.String,System.Int32)">
            <summary>
            Execute a non-query SQL using ADO.NET
            </summary>
            <param name="connectionString"></param>
            <param name="command"></param>
            <param name="commandTimeout"></param>
            <returns></returns>
        </member>
        <member name="T:TestSupport.EfHelpers.SqliteInMemory">
            <summary>
            This static class contains extension methods to use with in-memory Sqlite databases
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.SqliteInMemory.CreateOptions``1(System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}})">
            <summary>
            Created a Sqlite Options for in-memory database. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqliteInMemory.CreateOptionsWithLogging``1(System.Action{TestSupport.EfHelpers.LogOutput},Microsoft.Extensions.Logging.LogLevel,System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}})">
            <summary>
            Created a Sqlite Options for in-memory database while capturing EF Core's logging output. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="efLog">This is a method that receives a LogOutput whenever EF Core logs something</param>
            <param name="logLevel">Optional: Sets the logLevel you want to capture. Defaults to Information</param>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqliteInMemory.CreateOptionsWithLogTo``1(System.Action{System.String},TestSupport.EfHelpers.LogToOptions,System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}})">
            <summary>
            Created a Sqlite Options for in-memory database while using LogTo to get the EF Core logging output. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="logAction">This action is called with each log output</param>
            <param name="logToOptions">Optional: This allows you to define what logs you want and what format. Defaults to LogLevel.Information</param>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqliteInMemory.SetupConnectionAndBuilderOptions``1(System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}})">
            <summary>
            Created a Sqlite Options for in-memory database. 
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:TestSupport.EfHelpers.SqlServerHelpers">
            <summary>
            This static class contains extension methods to use with SQL Server databases
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlServerHelpers.CreateUniqueClassOptions``1(System.Object,System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}})">
            <summary>
            This creates the DbContextOptions  options for a SQL server database, 
            where the database name is formed using the appsetting's DefaultConnection with the class name as a prefix.
            That is, the database is unique to the object provided
            </summary>
            <typeparam name="T"></typeparam>
            <param name="callingClass">this should be this, i.e. the class you are in</param>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlServerHelpers.CreateUniqueClassOptionsWithLogging``1(System.Object,System.Action{TestSupport.EfHelpers.LogOutput},Microsoft.Extensions.Logging.LogLevel,System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}})">
            <summary>
            This creates the DbContextOptions options for a SQL server database while capturing EF Core's logging output. 
            The database name is formed using the appsetting's DefaultConnection with the class name as a prefix.
            That is, the database is unique to the object provided
            </summary>
            <typeparam name="T"></typeparam>
            <param name="callingClass">this should be this, i.e. the class you are in</param>
            <param name="efLog">This is a method that receives a LogOutput whenever EF Core logs something</param>
            <param name="logLevel">Optional: Sets the logLevel you want to capture. Defaults to Information</param>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlServerHelpers.CreateUniqueClassOptionsWithLogTo``1(System.Object,System.Action{System.String},TestSupport.EfHelpers.LogToOptions,System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}})">
            <summary>
            This creates the DbContextOptions options for a SQL server database while capturing EF Core's logging output. 
            The database name is formed using the appsetting's DefaultConnection with the class name as a prefix.
            That is, the database is unique to the object provided
            </summary>
            <typeparam name="T"></typeparam>
            <param name="callingClass">this should be this, i.e. the class you are in</param>
            <param name="logAction">This action is called with each log output</param>
            <param name="logToOptions">Optional: This allows you to define what logs you want and what format. Defaults to LogLevel.Information</param>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlServerHelpers.CreateUniqueMethodOptions``1(System.Object,System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}},System.String)">
            <summary>
            This creates the DbContextOptions options for a SQL server database, 
            where the database name is formed using the appsetting's DefaultConnection with the class name and the calling method's name as as a prefix.
            That is, the database is unique to the calling method.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="callingClass">this should be this, i.e. the class you are in</param>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <param name="callingMember">Do not use: this is filled in by compiler</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlServerHelpers.CreateUniqueMethodOptionsWithLogging``1(System.Object,System.Action{TestSupport.EfHelpers.LogOutput},Microsoft.Extensions.Logging.LogLevel,System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}},System.String)">
            <summary>
            This creates the DbContextOptions  options for a SQL server database while capturing EF Core's logging output. 
            Where the database name is formed using the appsetting's DefaultConnection with the class name and the calling method's name as as a prefix.
            That is, the database is unique to the calling method.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="callingClass">this should be this, i.e. the class you are in</param>
            <param name="efLog">This is a method that receives a LogOutput whenever EF Core logs something</param>
            <param name="logLevel">Optional: Sets the logLevel you want to capture. Defaults to Information</param>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <param name="callingMember">Do not use: this is filled in by compiler</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlServerHelpers.CreateUniqueMethodOptionsWithLogTo``1(System.Object,System.Action{System.String},TestSupport.EfHelpers.LogToOptions,System.Action{Microsoft.EntityFrameworkCore.DbContextOptionsBuilder{``0}},System.String)">
            <summary>
            This creates the DbContextOptions  options for a SQL server database while capturing EF Core's logging output. 
            Where the database name is formed using the appsetting's DefaultConnection with the class name and the calling method's name as as a prefix.
            That is, the database is unique to the calling method.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="callingClass">this should be this, i.e. the class you are in</param>
            <param name="logAction">This action is called with each log output</param>
            <param name="logToOptions">Optional: This allows you to define what logs you want and what format. Defaults to LogLevel.Information</param>
            <param name="builder">Optional: action that allows you to add extra options to the builder</param>
            <param name="callingMember">Do not use: this is filled in by compiler</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.EfHelpers.SqlServerHelpers.CreateEmptyViaDelete(Microsoft.EntityFrameworkCore.DbContext)">
            <summary>
            This will ensure an empty database by deleting the current database and recreating it
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:TestSupport.EfHelpers.TimeThingResult">
            <summary>
            Result from a TimeThings instance once it is disposed
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.TimeThingResult.#ctor(System.Double,System.Int32,System.String)">
            <summary>
            Creates the TimeThingResult
            </summary>
            <param name="totalTimeMilliseconds"></param>
            <param name="numRuns"></param>
            <param name="message"></param>
        </member>
        <member name="P:TestSupport.EfHelpers.TimeThingResult.TotalTimeMilliseconds">
            <summary>
            Total time in milliseconds, with fractions
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.TimeThingResult.NumRuns">
            <summary>
            Optional number of runs. zero if not set.
            </summary>
        </member>
        <member name="P:TestSupport.EfHelpers.TimeThingResult.Message">
            <summary>
            Optional string to identify this usage of the TimeThings
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.TimeThingResult.ToString">
            <summary>
            Provides a detailed report of the timed event
            </summary>
            <returns></returns>
        </member>
        <member name="T:TestSupport.EfHelpers.TimeThings">
            <summary>
            Use this in a using statement for timing things - time output to test output when class is disposes
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.TimeThings.#ctor(System.Action{TestSupport.EfHelpers.TimeThingResult},System.String,System.Int32)">
            <summary>
            This will measure the time it took from this class being created to it being disposed
            </summary>
            <param name="result">This action returns the TimeThingResult on dispose</param>
            <param name="message">Optional: a string to show in the result. Useful if you have multiple timing in a row</param>
            <param name="numRuns">Optional: if the timing covers multiple runs of something, then set numRuns to the number of runs and it will give you the average per run</param>
        </member>
        <member name="M:TestSupport.EfHelpers.TimeThings.#ctor(Xunit.Abstractions.ITestOutputHelper,System.String,System.Int32)">
            <summary>
            This will measure the time it took from this class being created to it being disposed and writes out to xUnit ITestOutputHelper
            </summary>
            <param name="output">On dispose it will write the result to the output</param>
            <param name="message">Optional: a string to show in the result. Useful if you have multiple timing in a row</param>
            <param name="numRuns">Optional: if the timing covers multiple runs of something, then set numRuns to the number of runs and it will give you the average per run</param>
        </member>
        <member name="M:TestSupport.EfHelpers.TimeThings.Dispose">
            <summary>
            When disposed it will return the result, either via a action or by an output
            </summary>
        </member>
        <member name="T:TestSupport.EfHelpers.WipeDbViaSql">
            <summary>
            This static class contains extension methods for quickly wiping a database using SQL commands
            </summary>
        </member>
        <member name="M:TestSupport.EfHelpers.WipeDbViaSql.CreateEmptyViaWipe(Microsoft.EntityFrameworkCore.DbContext,System.Boolean,System.Int32,System.Type[])">
            <summary>
            This will ensure an empty database by using the WipeAllDataFromDatabase method
            </summary>
            <param name="context"></param>
            <param name="addBracketsAndSchema">Optional: normally it only uses the table name, but for cases where you have multiple schemas,
            or a table name that needs brackets the you can set to to true. Default is false</param>
            <param name="maxDepth">Valuse to stop the wipe method from getting in a circular reference loop</param>
            <param name="excludeTypes">This allows you to provide the Types of the table that you don't want wiped. 
            Useful if you have a circular ref that WipeAllDataFromDatabase cannot handle. You then must wipe that part.</param>
            <returns>True if the database is created, false if it already existed.</returns>
        </member>
        <member name="M:TestSupport.EfHelpers.WipeDbViaSql.WipeAllDataFromDatabase(Microsoft.EntityFrameworkCore.DbContext,System.Boolean,System.Int32,System.Type[])">
            <summary>
            This is a fast way to delete all the rows in all the tables in a database. 
            Useful for unit testing where you need an empty database.
            This will work out the right order to delete rows from tables to avoid a delete behavour of Restrict
            from causing problems. Its not perfect (circular references can cause it problems) but it will throw
            an exception if it cannot acheive a wipe of the database
            </summary>
            <param name="context"></param>
            <param name="addBracketsAndSchema">Optional: normally it only uses the table name, but for cases where you have multiple schemas,
            or a table name that needs brackets the you can set to to true. Deafult is false</param>
            <param name="maxDepth">Value to stop the wipe method from getting in a circular reference loop. Defaults to 10</param>
            <param name="excludeTypes">This allows you to provide the Types of the table that you don't want wiped. 
            Useful if you have a circular ref that WipeAllDataFromDatabase cannot handle. You then must wipe that part yourself.</param>
        </member>
        <member name="T:TestSupport.Helpers.AppSettings">
            <summary>
            This is a static method that contains extension methods to get the configuation and form useful connection name strings
            </summary>
        </member>
        <member name="F:TestSupport.Helpers.AppSettings.UnitTestConnectionStringName">
            <summary>
            This is the default connection name that the AppSetting class expects
            </summary>
        </member>
        <member name="F:TestSupport.Helpers.AppSettings.RequiredEndingToUnitTestDatabaseName">
            <summary>
            Your unit test database name must end with this string.
            This is a safety measure to stop the DeleteAllUnitTestDatabases from deleting propduction databases
            </summary>
        </member>
        <member name="M:TestSupport.Helpers.AppSettings.GetConfiguration(System.Reflection.Assembly,System.String)">
            <summary>
            This will look for a appsettings.json file in the top level of the calling assembly and read content
            </summary>
            <param name="callingAssembly">If called by an internal method you must provide the other calling assembly</param>
            <param name="settingsFilename">This allows you to open a json configuration file of this given name</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.Helpers.AppSettings.GetConfiguration(System.String,System.String)">
            <summary>
            This will look for a appsettings.json file in the directory relative to the calling assembly
            </summary>
            <param name="relativeToCallingAssembly">A relative path relative to the top level directory of the assembly you are calling from
            e.g. "..\MyAspNetApp" would get the appsettings.json from a project directory "MyAspNetApp" at the same level as your test assembly</param>
            <param name="settingsFilename">This allows you to open a json configuration file of this given name</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.Helpers.AppSettings.GetUniqueDatabaseConnectionString(System.Object,System.String,System.Char)">
            <summary>
            This creates a unique database name based on the test class name, and an optional extra name
            </summary>
            <param name="testClass">This should be 'this' in the test, which means the class name is added to the end of the database name</param>
            <param name="optionalMethodName">This is an optional string which, if present, is added to the end of the database name</param>
            <param name="separator">Optional (defaults to _). This is the character used to separate each part of the formed name</param>
            <returns></returns>
        </member>
        <member name="T:TestSupport.Helpers.TestData">
            <summary>
            A static class containing extentions methods for accessing files
            </summary>
        </member>
        <member name="M:TestSupport.Helpers.TestData.GetFilePath(System.String,System.Reflection.Assembly)">
            <summary>
            This returns the filepath of the file found by the searchPattern. If more than one file found that throws and exception
            </summary>
            <param name="searchPattern">If the search pattern starts with a @"\", then it will look in a subdirectory for the file</param>
            <param name="callingAssembly">optional: provide the calling assembly. default is to use the current calling assembly</param>
            <returns>The absolute filepath to the found file</returns>
        </member>
        <member name="M:TestSupport.Helpers.TestData.GetFilePaths(System.String,System.Reflection.Assembly)">
            <summary>
            This returns all the filepaths of file that fit the search pattern
            </summary>
            <param name="searchPattern">If the search pattern starts with a @"\", then it will look for an alternate testdata directory</param>
            <param name="callingAssembly">optional: provide the calling assembly. default is to use the current calling assembly</param>
            <returns>array of absolute filepaths that match the filepath</returns>
        </member>
        <member name="M:TestSupport.Helpers.TestData.GetFileContent(System.String,System.Reflection.Assembly)">
            <summary>
            This returns the content of the file found by the searchPattern. If more than one file found that throws and exception
            </summary>
            <param name="searchPattern">If the search pattern starts with a @"\", then it will look in a subdirectory for the file</param>
            <param name="callingAssembly">optional: provide the calling assembly. default is to use the current calling assembly</param>
            <returns>The content of the file as text of the found file</returns>
        </member>
        <member name="M:TestSupport.Helpers.TestData.EnsureFileDeleted(System.String,System.Reflection.Assembly)">
            <summary>
            This will ensure that a file in the TestData directory is deleted
            </summary>
            <param name="searchPattern"></param>
            <param name="callingAssembly">optional: provide the calling assembly. default is to use the current calling assembly</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.Helpers.TestData.DeleteDirectoryAndAnyContent(System.String)">
            <summary>
            This will delete a directory and any files inside that directory.
            If no directory exists then it simply returns
            </summary>
            <param name="topDirPath"></param>
        </member>
        <member name="M:TestSupport.Helpers.TestData.DeleteAllFilesAndSubDirsInDir(System.String)">
            <summary>
            This deletes all files and directories (and subdirectories) in the given topDir.
            It does NOT delete the topDir directory
            </summary>
            <param name="topDirPath"></param>
        </member>
        <member name="M:TestSupport.Helpers.TestData.GetTestDataDir(System.String,System.Reflection.Assembly)">
            <summary>
            This will return the absolute file path to the TestData directory in the calling method's project 
            </summary>
            <param name="alternateTestDir">optional. If given then it can be relative or absolute path, which 
            replaces the default TestData directly</param>
            <param name="callingAssembly">optional: provide the calling assembly. default is to use the current calling assembly</param>
            <returns></returns>
        </member>
        <member name="M:TestSupport.Helpers.TestData.GetCallingAssemblyTopLevelDir(System.Reflection.Assembly)">
            <summary>
            This will return the absolute file path of the calling assembly, or the assembly provided 
            </summary>
            <param name="callingAssembly">optional: provide the calling assembly. default is to use the current calling assembly</param>
            <returns></returns>
        </member>
    </members>
</doc>
